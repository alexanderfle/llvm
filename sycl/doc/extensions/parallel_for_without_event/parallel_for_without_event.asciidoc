= parallel_for which does not return the event

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

// This is necessary for asciidoc, but not for asciidoctor
:cpp: C++

== Notice

IMPORTANT: This specification is a draft.

Copyright (c) 2021 Intel Corporation. All rights reserved.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are
trademarks of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc.
used by permission by Khronos.

NOTE: This document is better viewed when rendered as html with asciidoctor.
GitHub does not render image icons.

== Dependencies

This extension is written against the SYCL 2020 specification, Revision 3.

== Status

Working Draft

This is a preview extension specification, intended to provide early access to
a feature for review and community feedback. When the feature matures, this
specification may be released as a formal extension.

Because the interfaces defined by this specification are not final and are
subject to change they are not intended to be used by shipping software
products.

== Introduction

This extension adds the template parameter into standard API calls `parallel_for` for `sycl::queue` to change the returned value and internal behavior:
[source,c++]
----
  template <typename KernelName, typename ret_val = event, typename KernelType>
  ret_val parallel_for(range<1> NumWorkItems, const KernelType &KernelFunc);

  template <typename KernelName, typename ret_val = event, typename KernelType>
  ret_val parallel_for(range<2> NumWorkItems, const KernelType &KernelFunc);

  template <typename KernelName, typename ret_val = event, typename KernelType>
  ret_val parallel_for(range<3> NumWorkItems, const KernelType &KernelFunc);

  template <typename KernelName, typename ret_val = event, typename KernelType, int Dims>
  ret_val parallel_for(range<Dims> NumWorkItems, id<Dims> WorkItemOffset, const KernelType &KernelFunc);

  template <typename KernelName, typename ret_val = event, typename KernelType, int Dims>
  ret_val parallel_for(nd_range<Dims> ExecutionRange, const KernelType &KernelFunc);
----

Example of possible implementation:
[source,c++]
----
  template <typename KernelName = detail::auto_name, typename ret_val = event, typename KernelType>
  ret_val parallel_for(range<1> NumWorkItems,
                     _KERNELFUNCPARAM(KernelFunc) _CODELOCPARAM(&CodeLoc)) {
    _CODELOCARG(&CodeLoc);
     if constexpr (std::is_same<ret_val, event>::value) {
      return parallel_for_impl<KernelName>(NumWorkItems, KernelFunc, CodeLoc);
    } else {
      parallel_for_impl_without_event<KernelName>(NumWorkItems, KernelFunc, CodeLoc);
    }
  }
----

Performance improvement is the main motivation for using the new API.
if the application is not interested in returned events of each submission
and the kernels don't use accessors and don't have dependencies by events
then using the specific API will give performance improvement for
the application compared with the standard API. Since the new API
doesn't return an event, the application can wait for all kernels
by calling the `wait()` method on the same `sycl::queue`.

== Limitations

For using the new API, the following cases are not supported:

- accessors(global and local)

- streams

- interoperability

- specialization constants

- enable_profiling property for queue

Please note these restrictions(`accessors`, `streams`, `interoperability`, `specialization constants`) are also not available for the standard API since they use the handler class or the kernel class, which is not when you use the `sycl::queue::parallel_for`. They can be used in `sycl::queue::submit`, but not `sycl::queue::parallel_for`, so these restrictions are inherited from the standard API. It means all these restrictions do not require additional checks and cannot lead to UB as a result of the restriction of the API itself.
`enable_profiling property for queue` restriction is added due to the fact that we don't create event and don't return the `sycl::event` - it is easy to check and an exception will be thrown.

#### back-end limitations
[%header,cols="1,5"]
|===
|back-end   |Description
|OpenCL     | Supported.
|Level-zero | Temporary unsupported may be added later.
|CUDA       | Supported.
|===

All these restrictions made it possible not to do many internal unnecessary checks
during each submission, and also not create an event that the user does not need,
i.e new API executes fewer instructions, thereby saving the host time spent on each submission.
Using the API is well suited for a kernel that uses USM memory.

Advice1: if target backend supports https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/LocalMemory/SYCL_INTEL_local_memory.asciidoc[static local memory allocation feature] inside the kernel code, then it can be used instead of creating local accessors.

Advice2:
if there is a data race between kernels, then developer needs to use inorder queue to ensure correctness results, see the example below. Independent kernels that don't have data races can run using an out-of-order queue.

==  Observed performance gain
In the table observed performance gain of one submission using the API compared to standard API.

[%header,cols="1,5"]
|===
|back-end   | (call time of `parallel_for`) / (call time of the new `parallel_for`)
|CUDA       | ~ x1.5
|OpenCL     | ~ x1.15
|Level-zero | ~ x1.1
|===

----
Table notes:
* the results were obtained by submission of small kernels with no more than five arguments passed to the kernel
* improvements may differ from device to device.
* temporary workaround was prepared to measure the performance for level-zero.
----

Following is an example use-case:

[source,c++]
----
#include <sycl/sycl.hpp>

using namespace sycl;

int main() {
  const size_t buffer_size = 10;
  sycl::nd_range<1> range(buffer_size, 1);
  std::vector<int> values(buffer_size, 0.0f);

  queue Q(sycl::property::queue::in_order{}); // in_order queue should be used in cases when kernels have data races as in this example.
  int *dev_values = sycl::malloc_device<int>(values.size(), Q);
  Q.memcpy(dev_values, values.data(), values.size() * sizeof(int)).wait();


  Q.parallel_for<kernel_name1, void>(range, [=](sycl::nd_item<1> item) {
    do_smth1(); // it uses "dev_values"
  });

  Q.parallel_for<kernel_name2, void>(range, [=](sycl::nd_item<1> item) {
    do_smth2(); // it uses "dev_values"
  });

  Q.parallel_for<kernel_name3, void>(range, [=](sycl::nd_item<1> item) {
    auto& ref = *sycl::group_local_memory_for_overwrite<uint32_t[buffer_size]>(item.get_group());
    do_smth3(ref); // it uses "dev_values"
  });

  Q.wait();

  Q.memcpy(values.data(), dev_values, values.size() * sizeof(int)).wait();
  sycl::free(dev_values, Q);

  return 0;
}
----

== Version

Built On: {docdate} +
Revision: 1

== Issues

None.

== Revision History

[cols="5,15,15,70"]
[grid="rows"]
[options="header"]
|========================================
|Rev|Date|Author|Changes
|1|2021-08-05|Alexander Flegontov |*Initial public working draft*
|2|2021-08-13|Alexander Flegontov |*info about restrictions and implementation via an additional template parameter in the standard API*
|========================================

//************************************************************************
//Other formatting suggestions:
//
//* Use *bold* text for host APIs, or [source] syntax highlighting.
//* Use +mono+ text for device APIs, or [source] syntax highlighting.
//* Use +mono+ text for extension names, types, or enum values.
//* Use _italics_ for parameters.
//************************************************************************
